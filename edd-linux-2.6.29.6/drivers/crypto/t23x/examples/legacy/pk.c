
/*
 * pk.c
 *
 * Linux specific test application, 
 *
 * Copyright (c) 2007, 2008 Freescale Semiconductor, Inc.
 *
 * This program is free software; you can redistribute  it and/or modify it
 * under  the terms of  the GNU General  Public License as published by the
 * Free Software Foundation;  either version 2 of the  License, or (at your
 * option) any later version.
 *
 */

#include <string.h>

#include <string.h>
#include <stdio.h>

#include <Sec2.h>
#include "examples.h"


static const unsigned char add_p0data[] = {
    0x00, 0x00, 0x00, 0x00, 0x45, 0x65, 0x45, 0x65,
    0x45, 0x65, 0x45, 0x65, 0x45, 0x65, 0x45, 0x65,
    0x45, 0x65, 0x45, 0x65, 0x45, 0x65, 0x45, 0x65,
    0x45, 0x65, 0x45, 0x65, 0x45, 0x65, 0x45, 0x65
};

static const unsigned char add_p1data[] = {
    0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x22,
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22
};

static const unsigned char add_p3data[] = {
    0x00, 0x00, 0x00, 0x00, 0x99, 0x99, 0x99, 0x99,
    0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
    0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
    0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99
};

static const unsigned char add_exp_p4[] =  {
    0x00, 0x00, 0x00, 0x00, 0x67, 0x87, 0x67, 0x87,
    0x67, 0x87, 0x67, 0x87, 0x67, 0x87, 0x67, 0x87,
    0x67, 0x87, 0x67, 0x87, 0x67, 0x87, 0x67, 0x87,
    0x67, 0x87, 0x67, 0x87, 0x67, 0x87, 0x67, 0x87
};


int pkha_add(int fd)
{
    int           status, tstat;
    MOD_2OP_REQ   addReq;
    unsigned char p4data[32];


    memset(p4data,  0, 32);
    memset(&addReq, 0, sizeof(addReq));


    /* ADD test */
    addReq.opId       = DPD_MM_LDCTX_ADD_ULCTX;
    addReq.bDataBytes = 32;
    addReq.aDataBytes = 32;
    addReq.modBytes   = 32;
    addReq.outBytes   = 32;
    addReq.bData      = (unsigned char *)add_p0data;
    addReq.aData      = (unsigned char *)add_p1data;
    addReq.modData    = (unsigned char *)add_p3data;
    addReq.outData    = p4data;

    status = ioctl(fd, IOCTL_PROC_REQ_BLOCK_VIRTUAL, (int)&addReq);

    if (status)
    {
        if ((status == SEC2_INVALID_CHA_TYPE) ||
            (status == SEC2_CHA_ERROR))
        {
            consolemsg("pk", "pkha_add", "", "not supported");
            return 0;
        }
        else
        {
            printf("pk: pkha_add - driver error with 0x%08x\n", status);
            return -1;
        }
    }


    if (memcmp((unsigned char *)p4data,
               (unsigned char *)add_exp_p4,
               32) != 0)
    {
        consolemsg("pk", "pkha_add", "", "error");
        dumpm(p4data, 32);
        tstat = -1;
    }
    else
    {
        consolemsg("pk", "pkha_add", "", "OK");
        tstat = 0;
    }

    return(tstat);
}




static const unsigned char sub_p1data[] = {
    0x00, 0x00, 0x00, 0x00, 0x45, 0x65, 0x45, 0x65,
    0x45, 0x65, 0x45, 0x65, 0x45, 0x65, 0x45, 0x65,
    0x45, 0x65, 0x45, 0x65, 0x45, 0x65, 0x45, 0x65,
    0x45, 0x65, 0x45, 0x65, 0x45, 0x65, 0x45, 0x65
};

static const unsigned char sub_p0data[] = {
    0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x22,
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22
};

static const unsigned char sub_p3data[] = {
    0x00, 0x00, 0x00, 0x00, 0x99, 0x99, 0x99, 0x99,
    0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
    0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
    0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99
};

static const unsigned char sub_exp_p4[] = {
    0x00, 0x00, 0x00, 0x00, 0x23, 0x43, 0x23, 0x43,
    0x23, 0x43, 0x23, 0x43, 0x23, 0x43, 0x23, 0x43,
    0x23, 0x43, 0x23, 0x43, 0x23, 0x43, 0x23, 0x43,
    0x23, 0x43, 0x23, 0x43, 0x23, 0x43, 0x23, 0x43
};



int pkha_subtract(int fd)
{
    int status, tstat;
    MOD_2OP_REQ   subReq;
    unsigned char p4data[256];

    memset (p4data,  0, 256);
    memset (&subReq, 0, sizeof(subReq));

    /* SUBTRACT test */
    subReq.opId       = DPD_MM_LDCTX_SUB_ULCTX;
    subReq.bDataBytes = 28;
    subReq.aDataBytes = 28;
    subReq.modBytes   = 28;
    subReq.outBytes   = 28;
    subReq.bData      = (unsigned char *)sub_p0data;
    subReq.aData      = (unsigned char *)sub_p1data;
    subReq.modData    = (unsigned char *)sub_p3data;
    subReq.outData    = p4data;

    status = ioctl(fd, IOCTL_PROC_REQ_BLOCK_VIRTUAL, (int)&subReq);

    if (status)
    {
        if ((status == SEC2_INVALID_CHA_TYPE) ||
            (status == SEC2_CHA_ERROR))
        {
            consolemsg("pk", "pkha_subtract", "", "not supported");
            return 0;
        }
        else
        {
            printf("pk: pkha_subtract - driver error with 0x%08x\n", status);
            return -1;
        }
    }


    if (memcmp((unsigned char *)p4data,
               (unsigned char *)sub_exp_p4,
               28) != 0)
    {
        consolemsg("pk", "pkha_subtract", "", "error");
        dumpm(p4data, 28);
        tstat = -1;
    }
    else
    {
        consolemsg("pk", "pkha_subtract", "", "OK");
        tstat = 0;
    }

    return(tstat);
}




#define MUL2_DATASIZE (128)

static const unsigned char mul2_p0data[] =
{
    0x5f, 0xed, 0x51, 0x23, 0x5f, 0xed, 0x51, 0x23,
    0x5f, 0xed, 0x51, 0x23, 0x5f, 0xed, 0x51, 0x23,
    0x5f, 0xed, 0x51, 0x23, 0x5f, 0xed, 0x51, 0x23,
    0x5f, 0xed, 0x51, 0x23, 0x5f, 0xed, 0x51, 0x23,
    0x5f, 0xed, 0x51, 0x23, 0x5f, 0xed, 0x51, 0x23,
    0x5f, 0xed, 0x51, 0x23, 0x5f, 0xed, 0x51, 0x23,
    0x5f, 0xed, 0x51, 0x23, 0x5f, 0xed, 0x51, 0x23,
    0x5f, 0xed, 0x51, 0x23, 0x5f, 0xed, 0x51, 0x23,
    0x5f, 0xed, 0x51, 0x23, 0x5f, 0xed, 0x51, 0x23,
    0x5f, 0xed, 0x51, 0x23, 0x5f, 0xed, 0x51, 0x23,
    0x5f, 0xed, 0x51, 0x23, 0x5f, 0xed, 0x51, 0x23,
    0x5f, 0xed, 0x51, 0x23, 0x5f, 0xed, 0x51, 0x23,
    0x5f, 0xed, 0x51, 0x23, 0x5f, 0xed, 0x51, 0x23,
    0x5f, 0xed, 0x51, 0x23, 0x5f, 0xed, 0x51, 0x23,
    0x5f, 0xed, 0x51, 0x23, 0x5f, 0xed, 0x51, 0x23,
    0x5f, 0xed, 0x51, 0x23, 0x5f, 0xed, 0x51, 0x23
};

static const unsigned char mul2_p1data[] =
{
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
    0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef
};

static const unsigned char mul2_p3data[] =
{
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,
    0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5
};

static const unsigned char mul2_exp_p4[] =
{
    0x02, 0x35, 0x24, 0xef, 0x02, 0x35, 0x24, 0xef,
    0x02, 0x35, 0x24, 0xef, 0x02, 0x35, 0x24, 0xef,
    0x02, 0x35, 0x24, 0xef, 0x02, 0x35, 0x24, 0xef,
    0x02, 0x35, 0x24, 0xef, 0x02, 0x35, 0x24, 0xef,
    0x02, 0x35, 0x24, 0xef, 0x02, 0x35, 0x24, 0xef,
    0x02, 0x35, 0x24, 0xef, 0x02, 0x35, 0x24, 0xef,
    0x02, 0x35, 0x24, 0xef, 0x02, 0x35, 0x24, 0xef,
    0x02, 0x35, 0x24, 0xef, 0x02, 0x35, 0x24, 0xef,
    0x02, 0x35, 0x24, 0xef, 0x02, 0x35, 0x24, 0xef,
    0x02, 0x35, 0x24, 0xef, 0x02, 0x35, 0x24, 0xef,
    0x02, 0x35, 0x24, 0xef, 0x02, 0x35, 0x24, 0xef,
    0x02, 0x35, 0x24, 0xef, 0x02, 0x35, 0x24, 0xef,
    0x02, 0x35, 0x24, 0xef, 0x02, 0x35, 0x24, 0xef,
    0x02, 0x35, 0x24, 0xef, 0x02, 0x35, 0x24, 0xef,
    0x02, 0x35, 0x24, 0xef, 0x02, 0x35, 0x24, 0xef,
    0x02, 0x35, 0x24, 0xef, 0x02, 0x35, 0x24, 0xef
};


int pkha_mul2(int fd)
{
    int         status, tstat;
    MOD_2OP_REQ mult2Req;

    unsigned char p4data[MUL2_DATASIZE];

    memset(p4data,    0, MUL2_DATASIZE);
    memset(&mult2Req, 0, sizeof(mult2Req));

    /* MULT2 test */
    mult2Req.opId       = DPD_MM_LDCTX_MUL2_ULCTX;
    mult2Req.bDataBytes = MUL2_DATASIZE;
    mult2Req.aDataBytes = MUL2_DATASIZE;
    mult2Req.modBytes   = MUL2_DATASIZE;
    mult2Req.outBytes   = MUL2_DATASIZE;
    mult2Req.bData      = (unsigned char *)mul2_p0data;
    mult2Req.aData      = (unsigned char *)mul2_p1data;
    mult2Req.modData    = (unsigned char *)mul2_p3data;
    mult2Req.outData    = p4data;

    status = ioctl(fd, IOCTL_PROC_REQ_BLOCK_VIRTUAL, (int)&mult2Req);
    if (status)
    {
        if ((status == SEC2_INVALID_CHA_TYPE) ||
            (status == SEC2_CHA_ERROR))
        {
            consolemsg("pk", "pkha_mul2", "", "not supported");
            return 0;
        }
        else
        {
            printf("pk: pkha_mul2 - driver error with 0x%08x\n", status);
            return -1;
        }
    }


    if (memcmp((unsigned char *)p4data,
               (unsigned char *)mul2_exp_p4,
               MUL2_DATASIZE) != 0)
    {
        consolemsg("pk", "pkha_mul2", "", "error");
        dumpm(p4data, MUL2_DATASIZE);
        tstat = -1;
    }
    else
    {
        consolemsg("pk", "pkha_mul2", "", "OK");
        tstat = 0;
    }

    return(tstat);
}






static const unsigned char f2mmul2_p0data[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xb5, 0xdb, 0xef, 0x4d,
    0x54, 0x20, 0xcc, 0x1a, 0x86, 0xc9, 0x89, 0x67
    };

static const unsigned char f2mmul2_p1data[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x12, 0x34, 0x56, 0x78,
    0x90, 0xab, 0xcd, 0xef, 0x01, 0xb2, 0x37, 0x3c,
    0x16, 0xfb, 0x0b, 0xa9, 0x1b, 0x80, 0xa8, 0x10
};

static const unsigned char f2mmul2_p3data[] =
{
    0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x92, 0xfe,
    0x77, 0xe7, 0x0c, 0x12, 0xa4, 0x23, 0x4c, 0x33
};

static const unsigned char f2mmul2_exp_p4[] =
{
    0x00, 0x00, 0x00, 0x01, 0x6b, 0x9e, 0x7b, 0x1e,
    0x6d, 0x4b, 0x7b, 0x64, 0xe4, 0x2a, 0xe5, 0xc4,
    0x1d, 0x1b, 0x0e, 0xe5, 0x2f, 0xb1, 0xd1, 0xdf
};



int pkha_f2m_mult2(int fd)
{
    int         status, tstat;
    MOD_2OP_REQ f2m_mult2Req;

    unsigned char p4data[256];

    memset (p4data, 0, 256);
    memset (&f2m_mult2Req, 0, sizeof(f2m_mult2Req));


    /* F2M MULT2 test */
    f2m_mult2Req.opId       = DPD_POLY_LDCTX_A0_B0_MUL2_ULCTX;
    f2m_mult2Req.bDataBytes = 256;
    f2m_mult2Req.aDataBytes = 256;
    f2m_mult2Req.modBytes   = 24;
    f2m_mult2Req.outBytes   = 24;
    f2m_mult2Req.bData      = (unsigned char *)f2mmul2_p0data;
    f2m_mult2Req.aData      = (unsigned char *)f2mmul2_p1data;
    f2m_mult2Req.modData    = (unsigned char *)f2mmul2_p3data;
    f2m_mult2Req.outData    = p4data;

    status = ioctl(fd, IOCTL_PROC_REQ_BLOCK_VIRTUAL, (int)&f2m_mult2Req);
    if (status)
    {
        if ((status == SEC2_INVALID_CHA_TYPE) ||
            (status == SEC2_CHA_ERROR))
        {
            consolemsg("pk", "pkha_f2m_mult2", "", "not supported");
            return 0;
        }
        else
        {
            printf("pk: pkha_f2m_mult2 - driver error with 0x%08x\n", status);
            return -1;
        }
    }


    if (memcmp((unsigned char *)p4data,
               (unsigned char *)f2mmul2_exp_p4,
               24) != 0)
    {
        consolemsg("pk", "pkha_f2m_mult2", "", "error");
        dumpm(p4data, 24);
        tstat = -1;
    }
    else
    {
        consolemsg("pk", "pkha_f2m_mult2", "", "OK");
        tstat = 0;
    }

    return(tstat);
}





static const unsigned char modp_p3data[] =
{
    0xf3, 0xc4, 0x4d, 0x17, 0x3c, 0x01, 0x2e, 0x0a,
    0xec, 0x59, 0x15, 0xab, 0xe4, 0xc8, 0x9b, 0x89,
    0xaa, 0x08, 0xac, 0x54, 0x5a, 0x0a, 0x0f, 0xb5,
    0xaa, 0x08, 0xac, 0x54, 0x5a, 0x0a, 0x0f, 0xb5,
    0xaa, 0x08, 0xac, 0x54, 0x5a, 0x0a, 0x0f, 0xb5
};

static const unsigned char modp_exp_p4[] =
{
    0x37, 0x8e, 0x17, 0x36, 0x7d, 0x63, 0xf8, 0xec,
    0xc7, 0x19, 0x9d, 0xbd, 0xa1, 0x16, 0xea, 0x99,
    0xb8, 0x60, 0x69, 0x84, 0xa0, 0x35, 0x31, 0xa4,
    0xd5, 0xd1, 0x0d, 0x59, 0x06, 0x45, 0x36, 0x8b,
    0x18, 0x74, 0xe0, 0xa3, 0xbb, 0xe2, 0x51, 0xeb
};


int pkha_rrmodp(int fd)
{
    int            status, tstat;
    MOD_RRMODP_REQ rrmodpReq;
    unsigned char  p4data[256];

    memset(p4data, 0, 256);
    memset(&rrmodpReq, 0, sizeof(rrmodpReq));


    /* RRMODP test */
    rrmodpReq.opId     = DPD_MM_LDCTX_RRMODP_ULCTX;
    rrmodpReq.nBytes   = 64;
    rrmodpReq.pBytes   = 40;
    rrmodpReq.outBytes = 40;
    rrmodpReq.pData    = (unsigned char *)modp_p3data;
    rrmodpReq.outData  = p4data;

    status = ioctl(fd, IOCTL_PROC_REQ_BLOCK_VIRTUAL, (int)&rrmodpReq);
    if (status)
    {
        if ((status == SEC2_INVALID_CHA_TYPE) ||
            (status == SEC2_CHA_ERROR))
        {
            consolemsg("pk", "pkha_rrmodp", "", "not supported");
            return 0;
        }
        else
        {
            printf("pk: pkha_rrmodp - driver error with 0x%08x\n", status);
            return -1;
        }
    }


    if (memcmp((unsigned char *)p4data,
               (unsigned char *)modp_exp_p4,
               40) != 0)
    {
        consolemsg("pk", "pkha_rrmodp", "", "error");
        dumpm(p4data, 40);
        tstat = -1;
    }
    else
    {
        consolemsg("pk", "pkha_rrmodp", "", "OK");
        tstat = 0;
    }

    return(tstat);
}




#define EXPO_DATA_SIZE (128)


static const unsigned char A[] =
{
    0x73, 0x61, 0x50, 0xba, 0x84, 0xc4, 0x06, 0xa7,
    0x15, 0xad, 0x1c, 0xe1, 0x73, 0x6c, 0xcd, 0xf4,
    0x74, 0x15, 0xb2, 0x31, 0x9a, 0xc0, 0xe7, 0xff,
    0x60, 0xae, 0x5d, 0x1d, 0x5b, 0xad, 0x54, 0x79,
    0x4c, 0xcc, 0xf7, 0x05, 0xfb, 0xad, 0x14, 0x4b,
    0xdd, 0xf2, 0xa2, 0x9a, 0xdf, 0xbd, 0x86, 0xa8,
    0x14, 0x89, 0xf0, 0x14, 0xa6, 0x83, 0x52, 0xbb,
    0xdc, 0x8d, 0x65, 0x1c, 0xa0, 0x0b, 0x5b, 0x45,
    0xf3, 0x86, 0xc6, 0x96, 0x7d, 0x8c, 0x82, 0x54,
    0x2b, 0xff, 0xda, 0x95, 0x5a, 0xae, 0xe9, 0x8d,
    0x85, 0xbb, 0x7c, 0xc4, 0x55, 0xe7, 0x29, 0x0e,
    0x55, 0x5a, 0xb6, 0xcc, 0x61, 0xb6, 0x5c, 0xc7,
    0x1c, 0x7f, 0x36, 0x18, 0xba, 0xd8, 0x1d, 0x22,
    0xac, 0x96, 0x0e, 0x6e, 0x5a, 0x14, 0xa2, 0xed,
    0x20, 0x9f, 0x88, 0xc3, 0x58, 0x7b, 0xbd, 0xff,
    0x3e, 0x4e, 0xab, 0x48, 0xaf, 0x0a, 0x66, 0x96
};

static const unsigned char B[] =
{
    0xea, 0x9a, 0x32, 0x2f, 0xe7, 0xc8, 0x1b, 0x53,
    0x80, 0x0c, 0xf6, 0x43, 0x3e, 0xf9, 0x44, 0xf5,
    0xfe, 0x9b, 0x95, 0x35, 0x79, 0x35, 0xcd, 0xd8,
    0xf1, 0x07, 0x03, 0xa5, 0x97, 0xd7, 0xe6, 0x5d,
    0x6d, 0xc1, 0x34, 0xa2, 0xb7, 0xcb, 0x07, 0x48,
    0xac, 0x59, 0x78, 0xe2, 0x73, 0x40, 0xd7, 0x8d,
    0x54, 0xaa, 0x00, 0x22, 0x99, 0x47, 0xa0, 0xf8,
    0x13, 0xcc, 0xb9, 0x24, 0x7c, 0x13, 0x0a, 0xc0,
    0xc5, 0xda, 0xb0, 0x70, 0xe6, 0xb8, 0xcb, 0xd1,
    0x89, 0xbb, 0x25, 0x6c, 0x31, 0x6e, 0x4e, 0xcf,
    0xa1, 0x0a, 0x0c, 0x8b, 0xa0, 0xd9, 0x86, 0x50,
    0xe8, 0x7e, 0xc9, 0x88, 0x30, 0x6c, 0xf8, 0x98,
    0xfb, 0x23, 0xe9, 0xce, 0x07, 0x72, 0xa1, 0x9f,
    0x3e, 0xaf, 0xfb, 0x4b, 0xbe, 0x85, 0x6b, 0xd9,
    0x9b, 0x65, 0x59, 0xf6, 0xb2, 0x9b, 0x94, 0x9b,
    0x76, 0x1c, 0x28, 0x46, 0xf6, 0x07, 0xb0, 0xaa
};

static const unsigned char C[] =
{
    0xdf, 0xa3, 0xe4, 0xfb, 0x4c, 0xca, 0xae, 0x27,
    0xc1, 0xa0, 0x87, 0x3d, 0x02, 0x09, 0x8c, 0x6b,
    0x90, 0x73, 0xbe, 0x60, 0xe5, 0x39, 0x6f, 0x8a,
    0x90, 0xe8, 0x60, 0x27, 0x99, 0x77, 0xcd, 0x6e,
    0x59, 0x9b, 0x0c, 0x40, 0x6b, 0x17, 0x36, 0x51,
    0x82, 0x91, 0x5a, 0xdd, 0x8b, 0xc4, 0x34, 0x0c,
    0xd7, 0xf6, 0x2a, 0xb0, 0xc0, 0xbd, 0x7f, 0xc8,
    0x95, 0x58, 0xa1, 0xef, 0xbc, 0x32, 0xb1, 0xf9,
    0xca, 0x8c, 0x16, 0xf2, 0x7f, 0xea, 0x12, 0x0f,
    0x78, 0xe4, 0x6b, 0x6d, 0x62, 0x24, 0xfa, 0x54,
    0x97, 0x5a, 0x0e, 0xcc, 0x75, 0xde, 0xcd, 0x87,
    0xf8, 0xe4, 0xb6, 0xcf, 0x1c, 0x3d, 0x71, 0x4a,
    0xe5, 0x6b, 0x57, 0x75, 0xd5, 0xa8, 0x71, 0x4d,
    0x35, 0x35, 0xf2, 0xdd, 0x0b, 0xda, 0x16, 0x6a,
    0xe1, 0x28, 0xbe, 0xb0, 0x03, 0xc1, 0x86, 0xe4,
    0xf0, 0xdd, 0x7d, 0xf9, 0x78, 0x08, 0xb7, 0xb5
};

static const unsigned char exp[] =
{
    0x80, 0x69, 0xb2, 0xb5, 0xb3, 0x48, 0xea, 0x46,
    0xe7, 0xa9, 0xad, 0x6b, 0x01, 0x0e, 0x95, 0x81,
    0xee, 0xc6, 0xc1, 0xaf, 0xb0, 0x9c, 0x16, 0x8a,
    0xfd, 0xca, 0x0a, 0xac, 0xad, 0xb0, 0xcd, 0x50,
    0x46, 0x0f, 0x45, 0x0c, 0xdd, 0xce, 0x0a, 0xe4,
    0x28, 0xa7, 0x8c, 0x62, 0x90, 0x00, 0x4a, 0xfb,
    0x81, 0x85, 0x1f, 0x5e, 0xc8, 0x8a, 0x84, 0x55,
    0x68, 0xe2, 0xe5, 0x35, 0x96, 0x08, 0x9a, 0x4b,
    0x3f, 0x34, 0x89, 0x8a, 0xc7, 0xe1, 0x45, 0x68,
    0x8a, 0x16, 0x0b, 0x60, 0xc1, 0xad, 0x05, 0x0c,
    0x62, 0x5f, 0x54, 0x04, 0x29, 0x7c, 0x44, 0xd5,
    0x7c, 0x84, 0xca, 0x01, 0xb2, 0xf6, 0xf3, 0x08,
    0xa6, 0x29, 0x6b, 0xbe, 0xac, 0xfe, 0xa4, 0xfa,
    0x6e, 0x86, 0xe1, 0x2c, 0xda, 0xee, 0xb0, 0xe3,
    0xac, 0xae, 0xbf, 0x81, 0x50, 0x92, 0x64, 0x0b,
    0xf9, 0x89, 0xaa, 0x24, 0x02, 0x5f, 0x33, 0x99
};


int expo(int fd)
{
    int            status;
    unsigned char  result[EXPO_DATA_SIZE];
    MOD_SS_EXP_REQ ModExpReq;



    memset(result, 0, sizeof(result));
    memset(&ModExpReq, 0, sizeof(ModExpReq));

    ModExpReq.opId       = DPD_MM_SS_RSA_EXP;

    ModExpReq.aData      = (unsigned char*)A;
    ModExpReq.aDataBytes = EXPO_DATA_SIZE;

    ModExpReq.expData    = (unsigned char*)B;
    ModExpReq.expBytes   = EXPO_DATA_SIZE;

    ModExpReq.modData    = (unsigned char*)C;
    ModExpReq.modBytes   = EXPO_DATA_SIZE;

    ModExpReq.bData      = result;
    ModExpReq.bDataBytes   = EXPO_DATA_SIZE;


    status = ioctl(fd, IOCTL_PROC_REQ_BLOCK_VIRTUAL, &ModExpReq);

    if (status)
    {
        if ((status == SEC2_INVALID_CHA_TYPE) ||
            (status == SEC2_CHA_ERROR))
        {
            consolemsg("pk", "expo", "", "not supported");
            return 0;
        }
        else
        {
            printf("pk: expo - driver error with 0x%08x\n", status);
            return -1;
        }
    }


    if (memcmp(exp, result, EXPO_DATA_SIZE))
    {
        consolemsg("pk", "expo", "", "error");
        dumpm(result, EXPO_DATA_SIZE);
        return -1;

    }
    else
    {
        consolemsg("pk", "expo", "", "OK");
        return 0;
    }
}


/* input a0 = 19 bytes */
static const unsigned char pqf2mAff_a0[] =
{
    0x04, 0x2d, 0x9c, 0x6c, 0xf4, 0x20, 0xd2, 0x8f,
    0x5d, 0xf5, 0xef, 0x21, 0xa3, 0x29, 0xf3, 0xc2,
    0x0a, 0xb0, 0xa5
};

/* input a1 = 19 bytes */
static const unsigned char pqf2mAff_a1[] =
{
    0x04, 0xed, 0x25, 0x64, 0x5c, 0x5e, 0x0a, 0xa3,
    0x54, 0xb8, 0x19, 0x3e, 0xab, 0xcd, 0x09, 0x75,
    0x00, 0x2d, 0x31
};

/* input a2 = 19 bytes */
static const unsigned char pqf2mAff_a2[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01
};

/* input a3 = 19 bytes */
static const unsigned char pqf2mAff_a3[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00
};

/* input b1 = 19 bytes */
static const unsigned char pqf2mAff_b0[] =
{
    0x03, 0x06, 0x2e, 0x4f, 0x2d, 0xb1, 0x7b, 0xfc,
    0x75, 0x1f, 0xa4, 0xab, 0xb5, 0x22, 0xf3, 0xe7,
    0xb7, 0x97, 0xb2
};

/* input b2 = 19 bytes */
static const unsigned char pqf2mAff_b1[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00
};

static const unsigned char pqf2mAff_n[] =
{
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
    0x00, 0x00, 0x01
};

static const unsigned char pqf2mAff_e[] =
{
    0x03
};

static const unsigned char pqf2mAff_exp_b1[] =
{
    0x09, 0xa5, 0x55, 0x55, 0x9b, 0xf2, 0x2e, 0xf0,
    0xa1, 0xbf, 0x61, 0xa9, 0xe8, 0x5d, 0x47, 0xda,
    0x95, 0x25, 0xfb
};

static const unsigned char pqf2mAff_exp_b2[] =
{
    0x00, 0x33, 0x9d, 0xc8, 0x47, 0xed, 0xd9, 0xe2,
    0x99, 0x11, 0x14, 0x27, 0x73, 0xff, 0xff, 0xdb,
    0xcb, 0xb0, 0xe4
};


/* Is 768 for T3, 384 for T2 */
#define PK_SPK_BUILD_SIZE 768

int pkf2maffine(int fd)
{
    int              stat, tstat;
    ECC_SPKBUILD_REQ ecc_buildReq;
    ECC_POINT_REQ    eccPtRq;
    unsigned char    buildOut[PK_SPK_BUILD_SIZE], b1out[19], b2out[19];

    tstat  = 0;
    memset(buildOut, 0, PK_SPK_BUILD_SIZE);
    memset(b1out, 0, 19);
    memset(b2out, 0, 19);
    memset(&ecc_buildReq, 0, sizeof(ecc_buildReq));
    memset(&eccPtRq, 0, sizeof(eccPtRq));


    ecc_buildReq.opId            = DPD_EC_SPKBUILD;

    ecc_buildReq.a0Data          = (unsigned char *)pqf2mAff_a0;
    ecc_buildReq.a0DataBytes     = 19;

    ecc_buildReq.a1Data          = (unsigned char *)pqf2mAff_a1;
    ecc_buildReq.a1DataBytes     = 19;

    ecc_buildReq.a2Data          = (unsigned char *)pqf2mAff_a2;
    ecc_buildReq.a2DataBytes     = 19;

    ecc_buildReq.a3Data          = (unsigned char *)pqf2mAff_a3;
    ecc_buildReq.a3DataBytes     = 19;

    ecc_buildReq.b0Data          = (unsigned char *)pqf2mAff_b0;
    ecc_buildReq.b0DataBytes     = 19;

    ecc_buildReq.b1Data          = (unsigned char *)pqf2mAff_b1;
    ecc_buildReq.b1DataBytes     = 19;

    ecc_buildReq.buildData       = buildOut;
    ecc_buildReq.buildDataBytes  = PK_SPK_BUILD_SIZE;


    eccPtRq.opId            = DPD_EC_F2M_AFF_PT_MULT;

    eccPtRq.nDataBytes      = 19;
    eccPtRq.nData           = (unsigned char *)pqf2mAff_n;

    eccPtRq.eDataBytes      = 1;
    eccPtRq.eData           = (unsigned char *)pqf2mAff_e;

    eccPtRq.buildDataBytes  = PK_SPK_BUILD_SIZE;
    eccPtRq.buildData       = buildOut;

    eccPtRq.b1DataBytes     = 19;
    eccPtRq.b1Data          = b1out;

    eccPtRq.b2DataBytes     = 19;
    eccPtRq.b2Data          = b2out;

    ecc_buildReq.nextReq = &eccPtRq;
    eccPtRq.nextReq      = NULL;


    stat = ioctl(fd, IOCTL_PROC_REQ_BLOCK_VIRTUAL, (int)&ecc_buildReq);
    if (stat)
    {
        if ((stat == SEC2_INVALID_CHA_TYPE) ||
            (stat == SEC2_CHA_ERROR))
        {
            consolemsg("pk", "f2maffine", "", "not supported");
            return 0;
        }
        else
        {
            printf("pk: f2maffine - driver error with 0x%08x\n", stat);
            return -1;
        }
    }

    if (memcmp(b1out, pqf2mAff_exp_b1, 19) != 0)
    {
        consolemsg("pk", "f2maffine", "B1 output", "error");
        dumpm(b1out, 19);
        tstat = -1;
    }
    if (memcmp(b2out, pqf2mAff_exp_b2, 19) != 0)
    {
        consolemsg("pk", "f2maffine", "B2 output", "error");
        dumpm(b2out, 19);
        tstat = -1;
    }

    if (!tstat)
        consolemsg("pk", "f2maffine", "", "OK");

  return(tstat);

}




static const unsigned char ptpqAff_MODULUS[] =  /* 20 bytes */
{
    0xed, 0xbe, 0x63, 0xac,
    0x07, 0xf2, 0x60, 0x10,
    0xfb, 0x91, 0xc1, 0x5f,
    0x9e, 0x5d, 0x75, 0xca,
    0x39, 0x3d, 0x73, 0x6b
};

static const unsigned char ptpqAff_e[] =  /* 20 bytes */
{
    0x02, 0x72, 0x27, 0x96,
    0x6b, 0x6b, 0x9f, 0x53,
    0x84, 0x1f, 0x7b, 0x03,
    0x2b, 0x2f, 0xa9, 0x30,
    0x35, 0x28, 0xb2, 0xf2
};


static const unsigned char ptpqAff_a0[] =
{
    0xe1, 0x34, 0x60, 0x37,
    0x7d, 0x80, 0xa4, 0x91,
    0xae, 0x4a, 0x06, 0x9f,
    0xcf, 0x1c, 0xcf, 0xf3,
    0x7a, 0xe0, 0x72, 0x33,
};

static const unsigned char ptpqAff_a1[] =
{
    0xea, 0x0a, 0xd5, 0xd3,
    0xde, 0x97, 0x7a, 0x76,
    0xdd, 0xc1, 0x7b, 0xb6,
    0xea, 0xb0, 0xc8, 0x2b,
    0x7f, 0x10, 0x8e, 0xf4,
};

static const unsigned char ptpqAff_a2[] =
{
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01,
};

static const unsigned char ptpqAff_a3[] =
{
    0xed, 0xbe, 0x63, 0xac,
    0x07, 0xf2, 0x60, 0x10,
    0xfb, 0x91, 0xc1, 0x5f,
    0x9e, 0x5d, 0x75, 0xca,
    0x39, 0x3d, 0x73, 0x68,
};

static const unsigned char ptpqAff_b0[] =
{
    0x01, 0x4f, 0x3c, 0x88,
    0xbf, 0xe1, 0xcc, 0xc6,
    0xa2, 0x2a, 0xfe, 0xc0,
    0x4a, 0x20, 0x53, 0xf3,
    0x14, 0x57, 0x6c, 0x9f,
};

static const unsigned char ptpqAff_b1[] =
{
    0x2b, 0x10, 0xce, 0x96,
    0x4c, 0xaf, 0xf6, 0xaa,
    0x50, 0xde, 0xa0, 0x75,
    0x0d, 0x84, 0x5d, 0x62,
    0x5c, 0xa7, 0x66, 0x11,
};


static const unsigned char ptpqAff_exp_b3[] = /* 20 bytes */
{
    0x68, 0x60, 0xae, 0x45,
    0x94, 0x34, 0x7c, 0xe1,
    0x5c, 0x9f, 0xdc, 0xd7,
    0xda, 0xb6, 0xad, 0x86,
    0xde, 0x0d, 0x09, 0xd7
};

static const unsigned char ptpqAff_exp_b2[] = /* 20 bytes */
{
    0x4f, 0xa2, 0x44, 0xb0,
    0x73, 0x22, 0xb3, 0xc8,
    0xa5, 0x6b, 0xb7, 0xde,
    0xb0, 0x17, 0xd9, 0xc4,
    0x0e, 0x1f, 0xbd, 0x8d
};

static const unsigned char ptpqAff_exp_b1[] = /* 20 bytes */
{
    0x31, 0x14, 0x71, 0x2d,
    0xf3, 0xa2, 0x38, 0xb4,
    0xe3, 0x20, 0x5d, 0x08,
    0x45, 0xb5, 0xc5, 0x0c,
    0xe3, 0xf5, 0xe3, 0xd1
};



int pkfpaffine(int fd)
{
    unsigned char     b1data[20], b2data[20], b3data[20], build[PK_SPK_BUILD_SIZE];
    int               stat, tstat;
    ECC_SPKBUILD_REQ  ecc_build;
    ECC_POINT_REQ     ecc_mulkptoqReq;

    tstat  = 0;

    memset(b1data,           0, 20);
    memset(b2data,           0, 20);
    memset(b3data,           0, 20);
    memset(build,            0, PK_SPK_BUILD_SIZE);
    memset(&ecc_build,       0, sizeof(ecc_build));
    memset(&ecc_mulkptoqReq, 0, sizeof(ecc_mulkptoqReq));


    ecc_build.opId                   = DPD_EC_SPKBUILD;

    ecc_build.a0Data                 = (unsigned char *)ptpqAff_a0;
    ecc_build.a0DataBytes            = 20;

    ecc_build.a1Data                 = (unsigned char *)ptpqAff_a1;
    ecc_build.a1DataBytes            = 20;

    ecc_build.a2Data                 = (unsigned char *)ptpqAff_a2;
    ecc_build.a2DataBytes            = 20;

    ecc_build.a3Data                 = (unsigned char *)ptpqAff_a3;
    ecc_build.a3DataBytes            = 20;

    ecc_build.b0Data                 = (unsigned char *)ptpqAff_b0;
    ecc_build.b0DataBytes            = 20;

    ecc_build.b1Data                 = (unsigned char *)ptpqAff_b1;
    ecc_build.b1DataBytes            = 20;

    ecc_build.buildData              = build;
    ecc_build.buildDataBytes         = PK_SPK_BUILD_SIZE;

    ecc_mulkptoqReq.opId             = DPD_EC_FP_AFF_LDCTX_kP_ULCTX;

    ecc_mulkptoqReq.nDataBytes       = 20;
    ecc_mulkptoqReq.nData            = (unsigned char *)ptpqAff_MODULUS;

    ecc_mulkptoqReq.eDataBytes       = 20;
    ecc_mulkptoqReq.eData            = (unsigned char *)ptpqAff_e;

    ecc_mulkptoqReq.buildDataBytes   = PK_SPK_BUILD_SIZE;
    ecc_mulkptoqReq.buildData        = build;

    ecc_mulkptoqReq.b1DataBytes      = 20;
    ecc_mulkptoqReq.b1Data           = b1data;

    ecc_mulkptoqReq.b2DataBytes      = 20;
    ecc_mulkptoqReq.b2Data           = b2data;

    ecc_mulkptoqReq.b3DataBytes      = 20;
    ecc_mulkptoqReq.b3Data           = b3data;

    ecc_build.nextReq = &ecc_mulkptoqReq;


    stat = ioctl(fd, IOCTL_PROC_REQ_BLOCK_VIRTUAL, (int)&ecc_build);
    if (stat)
    {
        if ((stat == SEC2_INVALID_CHA_TYPE) ||
            (stat == SEC2_CHA_ERROR))
        {
            consolemsg("pk", "fpaffine", "", "not supported");
            return 0;
        }
        else
        {
            printf("pk: fpaffine - driver error with 0x%08x\n", stat);
            return -1;
        }
    }


    if (memcmp(b1data, ptpqAff_exp_b1, 20) != 0)
    {
        consolemsg("pk", "fpaffine", "B1 output", "error");
        dumpm(b1data, 20);
        tstat = -1;
    }

    if (memcmp(b2data, ptpqAff_exp_b2, 20) != 0)
    {
        consolemsg("pk", "fpaffine", "B2 output", "error");
        dumpm(b2data, 20);
        tstat = -1;
    }

    if (memcmp(b3data, ptpqAff_exp_b3, 20) != 0)
    {
        consolemsg("pk", "fpaffine", "B3 output", "error");
        dumpm(b3data, 20);
        tstat = -1;
    }

    if (!tstat)
        consolemsg("pk", "fpaffine", "", "OK");

    return(tstat);
}



static const unsigned char ptpqAff2_MODULUS[] =
{
    0x04, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x08, 0x01
};


static const unsigned char ptpqAff2_e[] =
{
    0x00, 0x4b, 0x26, 0xda,
    0x96, 0x9e, 0xc0, 0xeb,
    0xf7, 0xa1, 0xea, 0x4f,
    0x75, 0xaa, 0x1c, 0x96,
    0xf0, 0xf6, 0x7a, 0x37,
    0x7f, 0x1e, 0x9f, 0x39,
    0xd4, 0x6b, 0xa5, 0x2d
};


static const unsigned char ptpqAff2_a0[] =
{
    0x01, 0xb2, 0x37, 0x3c,
    0x16, 0xfb, 0x0b, 0xa9,
    0x1b, 0x7c, 0xa8, 0x39,
    0x49, 0x22, 0xfe, 0xd6,
    0x1d, 0x07, 0x88, 0x43,
    0x57, 0x58, 0x0a, 0x81,
    0x0c, 0xaa, 0xa5, 0x53,
};

static const unsigned char ptpqAff2_a1[] =
{
    0x00, 0xc4, 0x42, 0x21,
    0x2f, 0xb2, 0x31, 0x69,
    0x64, 0x14, 0x33, 0x0a,
    0xb5, 0x7d, 0xbe, 0xf4,
    0xd5, 0x42, 0x0c, 0xc1,
    0xa8, 0x6c, 0x98, 0x96,
    0x77, 0x50, 0xe6, 0x5f,
};

static const unsigned char ptpqAff2_a2[] =
{
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01,
};

static const unsigned char ptpqAff2_a3[] =
{
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
};

static const unsigned char ptpqAff2_b0[] =
{
    0x03, 0x11, 0xd3, 0xc3,
    0xb6, 0xe7, 0x67, 0xb7,
    0x15, 0xb5, 0x3c, 0xad,
    0xda, 0x99, 0xa9, 0x80,
    0xa4, 0xfd, 0x71, 0x45,
    0xd3, 0xf4, 0xe7, 0x3b,
    0x26, 0x44, 0x78, 0xb2,
};

static const unsigned char ptpqAff2_b1[] =
{
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x04,
    0x00, 0x00, 0x10, 0x00
};

static const unsigned char ptpqAff2_exp_b1[] =
{
    0x02, 0xB3, 0x30, 0x45,
    0xA0, 0x97, 0x67, 0x90,
    0x3D, 0xA9, 0xA0, 0x78,
    0x90, 0xA8, 0x7E, 0xA8,
    0x65, 0xDE, 0x77, 0x41,
    0x5D, 0x8A, 0xB9, 0xBE,
    0x3E, 0x8C, 0x94, 0x69
};

static const unsigned char ptpqAff2_exp_b2[] =
{
    0x01, 0x72, 0x3E, 0xA9,
    0xA8, 0xBC, 0x14, 0x00,
    0x7C, 0x80, 0x09, 0xAD,
    0xCB, 0x36, 0x11, 0x31,
    0xD5, 0x42, 0x02, 0x36,
    0x06, 0xFE, 0xA9, 0xB9,
    0x2B, 0xAE, 0x97, 0x89
};




int pkf2maffine2(int fd)
{
    unsigned char    b1data[32], b2data[32], b3data[32], build[PK_SPK_BUILD_SIZE];
    int              stat, tstat;
    ECC_SPKBUILD_REQ ecc_build;
    ECC_POINT_REQ    ecc_f2mmulkptoqReq;

    tstat  = 0;

    memset(b1data, 0, 32);
    memset(b2data, 0, 32);
    memset(b3data, 0, 32);
    memset(build,  0, PK_SPK_BUILD_SIZE);
    memset(&ecc_build,          0, sizeof(ecc_build));
    memset(&ecc_f2mmulkptoqReq, 0, sizeof(ecc_f2mmulkptoqReq));

    ecc_build.opId                   = DPD_EC_SPKBUILD;

    ecc_build.a0Data                 = (unsigned char *)ptpqAff2_a0;
    ecc_build.a0DataBytes            = 28;

    ecc_build.a1Data                 = (unsigned char *)ptpqAff2_a1;
    ecc_build.a1DataBytes            = 28;

    ecc_build.a2Data                 = (unsigned char *)ptpqAff2_a2;
    ecc_build.a2DataBytes            = 28;

    ecc_build.a3Data                 = (unsigned char *)ptpqAff2_a3;
    ecc_build.a3DataBytes            = 28;

    ecc_build.b0Data                 = (unsigned char *)ptpqAff2_b0;
    ecc_build.b0DataBytes            = 28;

    ecc_build.b1Data                 = (unsigned char *)ptpqAff2_b1;
    ecc_build.b1DataBytes            = 28;

    ecc_build.buildData              = build;
    ecc_build.buildDataBytes         = PK_SPK_BUILD_SIZE;


    ecc_f2mmulkptoqReq.opId            = DPD_EC_F2M_AFF_LDCTX_kP_ULCTX;

    ecc_f2mmulkptoqReq.nDataBytes      = 28;
    ecc_f2mmulkptoqReq.nData           = (unsigned char *)ptpqAff2_MODULUS;

    ecc_f2mmulkptoqReq.eDataBytes      = 28;
    ecc_f2mmulkptoqReq.eData           = (unsigned char *)ptpqAff2_e;

    ecc_f2mmulkptoqReq.buildDataBytes  = PK_SPK_BUILD_SIZE;
    ecc_f2mmulkptoqReq.buildData       = (unsigned char *)build;

    ecc_f2mmulkptoqReq.b1DataBytes     = 32;
    ecc_f2mmulkptoqReq.b1Data          = b1data;

    ecc_f2mmulkptoqReq.b2DataBytes     = 32;
    ecc_f2mmulkptoqReq.b2Data          = b2data;

    ecc_f2mmulkptoqReq.b3DataBytes     = 32;
    ecc_f2mmulkptoqReq.b3Data          = b3data;

    ecc_build.nextReq = &ecc_f2mmulkptoqReq;

    stat = ioctl(fd, IOCTL_PROC_REQ_BLOCK_VIRTUAL, (int)&ecc_build);
    if (stat)
    {
        if ((stat == SEC2_INVALID_CHA_TYPE) ||
            (stat == SEC2_CHA_ERROR))
        {
            consolemsg("pk", "f2maffine2", "", "not supported");
            return 0;
        }
        else
        {
            printf("pk: f2maffine2 - driver error with 0x%08x\n", stat);
            return -1;
        }
    }



    if (memcmp(b1data, ptpqAff2_exp_b1, 28) != 0)
    {
      consolemsg("pk", "f2maffine2", "B1 output", "error");
      dumpm(b1data, 28);
      tstat = -1;
    }

    if (memcmp(b2data, ptpqAff2_exp_b2, 28) != 0)
    {
      consolemsg("pk", "f2maffine2", "B2 output", "error");
      dumpm(b2data, 28);
      tstat = -1;
    }

    if (!tstat)
        consolemsg("pk", "f2maffine2", "", "OK");

    return(tstat);
}



static const unsigned char fppqProj_MODULUS[] =
{
    0xed, 0xbe, 0x63, 0xac,
    0x07, 0xf2, 0x60, 0x10,
    0xfb, 0x91, 0xc1, 0x5f,
    0x9e, 0x5d, 0x75, 0xca,
    0x39, 0x3d, 0x73, 0x6b
};

static const unsigned char fppqProj_e[] =
{
    0x02, 0x72, 0x27, 0x96,
    0x6b, 0x6b, 0x9f, 0x53,
    0x84, 0x1f, 0x7b, 0x03,
    0x2b, 0x2f, 0xa9, 0x30,
    0x35, 0x28, 0xb2, 0xf2
};


static const unsigned char fppqProj_a0[] =
{
    0xe1, 0x34, 0x60, 0x37,
    0x7d, 0x80, 0xa4, 0x91,
    0xae, 0x4a, 0x06, 0x9f,
    0xcf, 0x1c, 0xcf, 0xf3,
    0x7a, 0xe0, 0x72, 0x33,
};

static const unsigned char fppqProj_a1[] =
{
    0xea, 0x0a, 0xd5, 0xd3,
    0xde, 0x97, 0x7a, 0x76,
    0xdd, 0xc1, 0x7b, 0xb6,
    0xea, 0xb0, 0xc8, 0x2b,
    0x7f, 0x10, 0x8e, 0xf4,
};

static const unsigned char fppqProj_a2[] =
{
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01,
};

static const unsigned char fppqProj_a3[] =
{
    0xed, 0xbe, 0x63, 0xac,
    0x07, 0xf2, 0x60, 0x10,
    0xfb, 0x91, 0xc1, 0x5f,
    0x9e, 0x5d, 0x75, 0xca,
    0x39, 0x3d, 0x73, 0x68,
};

static const unsigned char fppqProj_b0[] =
{
    0x01, 0x4f, 0x3c, 0x88,
    0xbf, 0xe1, 0xcc, 0xc6,
    0xa2, 0x2a, 0xfe, 0xc0,
    0x4a, 0x20, 0x53, 0xf3,
    0x14, 0x57, 0x6c, 0x9f,
};

static const unsigned char fppqProj_b1[] =
{
    0x2b, 0x10, 0xce, 0x96,
    0x4c, 0xaf, 0xf6, 0xaa,
    0x50, 0xde, 0xa0, 0x75,
    0x0d, 0x84, 0x5d, 0x62,
    0x5c, 0xa7, 0x66, 0x11
};

static const unsigned char fppqProj_exp_b3[] =
{
    0x2c, 0xb6, 0x98, 0x6e,
    0x6b, 0xd7, 0x18, 0x23,
    0x9d, 0x0a, 0x50, 0xc8,
    0x4a, 0xa4, 0xdd, 0xdb,
    0x79, 0x7a, 0x42, 0x6c
};

static const unsigned char fppqProj_exp_b2[] =
{
    0xa9, 0x73, 0x41, 0xb8,
    0x2c, 0x75, 0x73, 0x51,
    0x99, 0xc6, 0xff, 0x74,
    0x34, 0x97, 0xfe, 0x29,
    0xfe, 0x2b, 0x33, 0x47
};

static const unsigned char fppqProj_exp_b1[] =
{
    0x33, 0x3e, 0x1c, 0xb8,
    0x18, 0xc0, 0x19, 0xdf,
    0xbd, 0x30, 0x80, 0xa2,
    0xb3, 0x5b, 0x47, 0x66,
    0x39, 0x8c, 0xbb, 0xae
};


int pkfpprojective(int fd)
{
    unsigned char    b1data[32], b2data[32], b3data[32], build[PK_SPK_BUILD_SIZE];
    int              stat, tstat;
    ECC_SPKBUILD_REQ ecc_build;
    ECC_POINT_REQ    ecc_mulkptoqReq;

    tstat  = 0;

    memset(b1data, 0, 32);
    memset(b2data, 0, 32);
    memset(b3data, 0, 32);
    memset(build,  0, PK_SPK_BUILD_SIZE);
    memset(&ecc_build,       0, sizeof(ecc_build));
    memset(&ecc_mulkptoqReq, 0, sizeof(ecc_mulkptoqReq));


    ecc_build.opId                   = DPD_EC_SPKBUILD;

    ecc_build.a0Data                 = (unsigned char *)fppqProj_a0;
    ecc_build.a0DataBytes            = 20;

    ecc_build.a1Data                 = (unsigned char *)fppqProj_a1;
    ecc_build.a1DataBytes            = 20;

    ecc_build.a2Data                 = (unsigned char *)fppqProj_a2;
    ecc_build.a2DataBytes            = 20;

    ecc_build.a3Data                 = (unsigned char *)fppqProj_a3;
    ecc_build.a3DataBytes            = 20;

    ecc_build.b0Data                 = (unsigned char *)fppqProj_b0;
    ecc_build.b0DataBytes            = 20;

    ecc_build.b1Data                 = (unsigned char *)fppqProj_b1;
    ecc_build.b1DataBytes            = 20;

    ecc_build.buildData              = build;
    ecc_build.buildDataBytes         = PK_SPK_BUILD_SIZE;

    ecc_mulkptoqReq.opId             = DPD_EC_FP_PROJ_LDCTX_kP_ULCTX;

    ecc_mulkptoqReq.nDataBytes       = 20;
    ecc_mulkptoqReq.nData            = (unsigned char *)fppqProj_MODULUS;

    ecc_mulkptoqReq.eDataBytes       = 20;
    ecc_mulkptoqReq.eData            = (unsigned char *)fppqProj_e;

    ecc_mulkptoqReq.buildDataBytes   = PK_SPK_BUILD_SIZE;
    ecc_mulkptoqReq.buildData        = (unsigned char *)build;

    ecc_mulkptoqReq.b1DataBytes      = 32;
    ecc_mulkptoqReq.b1Data           = b1data;

    ecc_mulkptoqReq.b2DataBytes      = 32;
    ecc_mulkptoqReq.b2Data           = b2data;

    ecc_mulkptoqReq.b3DataBytes      = 32;
    ecc_mulkptoqReq.b3Data           = b3data;

    ecc_build.nextReq = &ecc_mulkptoqReq;

    stat = ioctl(fd, IOCTL_PROC_REQ_BLOCK_VIRTUAL, (int)&ecc_build);
    if (stat)
    {
        if ((stat == SEC2_INVALID_CHA_TYPE) ||
            (stat == SEC2_CHA_ERROR))
        {
            consolemsg("pk", "fpprojective", "", "not supported");
            return 0;
        }
        else
        {
            printf("pk: fpprojective - driver error with 0x%08x\n", stat);
            return -1;
        }
    }



    if (memcmp(b1data, fppqProj_exp_b1, 20) != 0)
    {
        consolemsg("pk", "fpprojective", "B1 output", "error");
        dumpm(b1data, 20);
        tstat = -1;
    }

    if (memcmp(b2data, fppqProj_exp_b2, 20) != 0)
    {
        consolemsg("pk", "fpprojective", "B2 output", "error");
        dumpm(b2data, 20);
        tstat = -1;
    }

    if (memcmp(b3data, fppqProj_exp_b3, 20) != 0)
    {
        consolemsg("pk", "fpprojective", "B3 output", "error");
        dumpm(b3data, 20);
        tstat = -1;
    }

    if (!tstat)
        consolemsg("pk", "fpprojective", "", "OK");

    return(tstat);
}






static const unsigned char p2qf2mProj_MODULUS[] =
{
    0x04, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x08, 0x01
};

static const unsigned char p2qf2mProj_e[] =
{
    0x00, 0x4b, 0x26, 0xda,
    0x96, 0x9e, 0xc0, 0xeb,
    0xf7, 0xa1, 0xea, 0x4f,
    0x75, 0xaa, 0x1c, 0x96,
    0xf0, 0xf6, 0x7a, 0x37,
    0x7f, 0x1e, 0x9f, 0x39,
    0xd4, 0x6b, 0xa5, 0x2d
};


static const unsigned char p2qf2mProj_a0[] =
{
    0x00, 0x00, 0x00, 0x00, 0x01, 0xb2, 0x37, 0x3c,
    0x16, 0xfb, 0x0b, 0xa9, 0x1b, 0x7c, 0xa8, 0x39,
    0x49, 0x22, 0xfe, 0xd6, 0x1d, 0x07, 0x88, 0x43,
    0x57, 0x58, 0x0a, 0x81, 0x0c, 0xaa, 0xa5, 0x53,

};

static const unsigned char p2qf2mProj_a1[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0xc4, 0x42, 0x21,
    0x2f, 0xb2, 0x31, 0x69, 0x64, 0x14, 0x33, 0x0a,
    0xb5, 0x7d, 0xbe, 0xf4, 0xd5, 0x42, 0x0c, 0xc1,
    0xa8, 0x6c, 0x98, 0x96, 0x77, 0x50, 0xe6, 0x5f,
};

static const unsigned char p2qf2mProj_a2[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
};

static const unsigned char p2qf2mProj_a3[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};

static const unsigned char p2qf2mProj_b0[] =
{
    0x00, 0x00, 0x00, 0x00, 0x03, 0x11, 0xd3, 0xc3,
    0xb6, 0xe7, 0x67, 0xb7, 0x15, 0xb5, 0x3c, 0xad,
    0xda, 0x99, 0xa9, 0x80, 0xa4, 0xfd, 0x71, 0x45,
    0xd3, 0xf4, 0xe7, 0x3b, 0x26, 0x44, 0x78, 0xb2,
};

static const unsigned char p2qf2mProj_b1[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x10, 0x00
};


static const unsigned char p2qf2mProj_exp_b1[] =
{
    0x02, 0x75, 0x58, 0x7c,
    0x9e, 0x6f, 0xf5, 0xc1,
    0x36, 0x71, 0xa5, 0x8b,
    0x2f, 0x50, 0x1e, 0x7e,
    0xe5, 0xf1, 0x98, 0xd9,
    0x44, 0x00, 0xb2, 0x6d,
    0x47, 0xbd, 0x1a, 0x1f
};

static const unsigned char p2qf2mProj_exp_b2[] =
{
    0x03, 0x05, 0x4d, 0xb9,
    0x7a, 0x24, 0x72, 0x2d,
    0x32, 0xbe, 0x9e, 0xeb,
    0x28, 0xca, 0x77, 0xa7,
    0xbb, 0x01, 0xee, 0x69,
    0xdc, 0xa6, 0x19, 0x5c,
    0xfb, 0xc0, 0xce, 0xe4
};

static const unsigned char p2qf2mProj_exp_b3[] =
{
    0x00, 0x54, 0x20, 0x08,
    0x2e, 0x28, 0xe3, 0x6f,
    0xb4, 0xef, 0x7c, 0x3b,
    0xb8, 0x21, 0x0f, 0x97,
    0x15, 0xc2, 0xd6, 0xc6,
    0x49, 0x06, 0x22, 0x41,
    0x57, 0xc8, 0xf4, 0xf2
};


int pkf2mprojective(int fd)
{
    unsigned char    b1data[32], b2data[32], b3data[32], build[PK_SPK_BUILD_SIZE];
    int              stat, tstat;
    ECC_SPKBUILD_REQ ecc_build;
    ECC_POINT_REQ    ecc_f2mmulkptoqReq;

    tstat  = 0;

    memset(b1data, 0, 32);
    memset(b2data, 0, 32);
    memset(b3data, 0, 32);
    memset(build,  0, PK_SPK_BUILD_SIZE);
    memset(&ecc_build,          0, sizeof(ecc_build));
    memset(&ecc_f2mmulkptoqReq, 0, sizeof(ecc_f2mmulkptoqReq));


    ecc_build.opId                   = DPD_EC_SPKBUILD;

    ecc_build.a0Data                 = (unsigned char *)p2qf2mProj_a0;
    ecc_build.a0DataBytes            = 32;

    ecc_build.a1Data                 = (unsigned char *)p2qf2mProj_a1;
    ecc_build.a1DataBytes            = 32;

    ecc_build.a2Data                 = (unsigned char *)p2qf2mProj_a2;
    ecc_build.a2DataBytes            = 32;

    ecc_build.a3Data                 = (unsigned char *)p2qf2mProj_a3;
    ecc_build.a3DataBytes            = 32;

    ecc_build.b0Data                 = (unsigned char *)p2qf2mProj_b0;
    ecc_build.b0DataBytes            = 32;

    ecc_build.b1Data                 = (unsigned char *)p2qf2mProj_b1;
    ecc_build.b1DataBytes            = 32;

    ecc_build.buildData              = build;
    ecc_build.buildDataBytes         = PK_SPK_BUILD_SIZE;

    ecc_f2mmulkptoqReq.opId             = DPD_EC_F2M_PROJ_LDCTX_kP_ULCTX;

    ecc_f2mmulkptoqReq.nDataBytes       = 28;
    ecc_f2mmulkptoqReq.nData            = (unsigned char *)p2qf2mProj_MODULUS;

    ecc_f2mmulkptoqReq.eDataBytes       = 28;
    ecc_f2mmulkptoqReq.eData            = (unsigned char *)p2qf2mProj_e;

    ecc_f2mmulkptoqReq.buildDataBytes   = PK_SPK_BUILD_SIZE;
    ecc_f2mmulkptoqReq.buildData        = (unsigned char *)build;

    ecc_f2mmulkptoqReq.b1DataBytes      = 32;
    ecc_f2mmulkptoqReq.b1Data           = b1data;

    ecc_f2mmulkptoqReq.b2DataBytes      = 32;
    ecc_f2mmulkptoqReq.b2Data           = b2data;

    ecc_f2mmulkptoqReq.b3DataBytes      = 32;
    ecc_f2mmulkptoqReq.b3Data           = b3data;

    ecc_build.nextReq = &ecc_f2mmulkptoqReq;

    stat = ioctl(fd, IOCTL_PROC_REQ_BLOCK_VIRTUAL, (int)&ecc_build);
    if (stat)
    {
        if ((stat == SEC2_INVALID_CHA_TYPE) ||
            (stat == SEC2_CHA_ERROR))
        {
            consolemsg("pk", "f2mprojective", "", "not supported");
            return 0;
        }
        else
        {
            printf("pk: f2mprojective - driver error with 0x%08x\n", stat);
            return -1;
        }
    }



    if (memcmp(b1data, p2qf2mProj_exp_b1, 28) != 0)
    {
        consolemsg("pk", "f2mprojective", "B1 output", "error");
        dumpm(b1data, 28);
        tstat = -1;
    }

    if (memcmp(b2data, p2qf2mProj_exp_b2, 28) != 0)
    {
        consolemsg("pk", "f2mprojective", "B2 output", "error");
        dumpm(b2data, 28);
        tstat = -1;
    }

    if (memcmp(b3data, p2qf2mProj_exp_b3, 28) != 0)
    {
        consolemsg("pk", "f2mprojective", "B3 output", "error");
        dumpm(b3data, 28);
        tstat = -1;
    }

    if (!tstat)
        consolemsg("pk", "f2mprojective", "", "OK");

    return(tstat);
}




int pk(int fd)
{
    int err, stat;

    err = 0;

    stat = pkha_add(fd);
    if (stat) err++;

    stat = pkha_subtract(fd);
    if (stat) err++;

    stat = pkha_mul2(fd);
    if (stat) err++;

    stat = pkha_f2m_mult2(fd);
    if (stat) err++;

    stat = expo(fd);
    if (stat) err++;

/*
    stat = pkha_rrmodp(fd);
    if (stat) err++;
*/
    stat = pkf2maffine(fd);
    if (stat) err++;

    stat = pkfpaffine(fd);
    if (stat) err++;

    stat = pkf2maffine2(fd);
    if (stat) err++;

    stat = pkfpprojective(fd);
    if (stat) err++;

    stat = pkf2mprojective(fd);
    if (stat) err++;

    if (err)
        return -1;
    else
        return 0;
}


